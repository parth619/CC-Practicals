2.Count the number of comments, keywords, identifiers, words,
lines and spaces from input file.




%{
#include <stdio.h>
#include <string.h>

int lc = 0, wc = 0, cc = 0, sc = 0, tc = 0, kw = 0, id = 0;
char *keywords[] = {
    "int", "float", "while", "do", "for", "if", "else",
    "switch", "case", "break", "continue", "char",
    "double", "long", "short", "typedef", "static",
    "enum", "const", "signed", "unsigned", "void",
    "struct", "union"
};

int is_keyword(char *text) {
    for (int i = 0; i < sizeof(keywords)/sizeof(keywords[0]); i++) {
        if (strcmp(text, keywords[i]) == 0)
            return 1;
    }
    return 0;
}
%}

%%
\n          { lc++; }
" "         { sc++; }
\t          { tc++; }
[a-zA-Z_][a-zA-Z0-9_]*  {
                if (is_keyword(yytext))
                    kw++;
                else
                    id++;
            }
.           { cc++; }
%%

int yywrap() {
    return 1;
}

int main() {
    printf("Enter the input (Ctrl+D to end):\n");
    yylex();

    printf("\n--- Count Summary ---\n");
    printf("Lines      : %d\n", lc);
    printf("Spaces     : %d\n", sc);
    printf("Tabs       : %d\n", tc);
    printf("Characters : %d\n", cc);
    printf("Keywords   : %d\n", kw);
    printf("Identifiers: %d\n", id);

    return 0;
}



3.Count number of words starting with 'A'.



%{
#include <stdio.h>
int count = 0;
%}

%%
[Aa][a-zA-Z]*   { count++; }     /* Matches any word starting with A or a */
.|\n            { ; }            /* Ignore all other characters */
%%

int main() {
    printf("Enter the text:\n");
    yylex();   // Start lexical analysis
    printf("\nNumber of words starting with 'A' or 'a' = %d\n", count);
    return 0;
}


4.Conversion of lowercase to uppercase and vice versa.



%{
#include <stdio.h>
%}
%%
[a-z]    { printf("%c", yytext[0] - 32); }
[A-Z]    { printf("%c", yytext[0] + 32); }
.        { printf("%c", yytext[0]); }
%%
int main() {
    yylex();
    return 0;
}





5. Conversion of decimal to hexadecimal number in a file.



%{
#include <stdio.h>
#include <stdlib.h>

void printHex(int num) {
    if (num == 0) {
        printf("0");
        return;
    }

    char hex[20];
    int i = 0;

    while (num > 0) {
        int rem = num % 16;
        if (rem < 10)
            hex[i++] = rem + '0';
        else
            hex[i++] = rem - 10 + 'A';
        num /= 16;
    }

    for (int j = i - 1; j >= 0; j--)
        putchar(hex[j]);
    putchar('\n');
}
%}

%%
[0-9]+ {
    int num = atoi(yytext);
    printHex(num);
}
\n     { }
.      { }
%%

int main() {
    yylex();
    return 0;
}




6.Test lines ending with ''com''.



%{
#include <stdio.h>
%}

%%
.*com     { printf("Line ends with 'com': %s\n", yytext); }
.*         { /* Ignore other lines */ }
%%

int main() {
    yylex();
    return 0;
}

int yywrap() {
    return 1;
}


7.Postfix Expression Evaluation.



lex code 


%{
#include "y.tab.h"
#include <stdlib.h>
%}

%%

[0-9]+      { yylval = atoi(yytext); return NUMBER; }
"+"         { return '+'; }
"-"         { return '-'; }
"*"         { return '*'; }
"/"         { return '/'; }
[ \t\n]     ;   // ignore spaces, tabs, newlines
.           { return yytext[0]; }

%%
int yywrap() { return 1; }





yacc code




%{
#include <stdio.h>
#include <stdlib.h>

int yylex(void);
void yyerror(const char *s);

int result;
int valid = 1;   // assume valid unless proven otherwise
%}

%token NUMBER

%%

input:
    expr   { result = $1; }
    ;

expr:
      expr expr '+'   { $$ = $1 + $2; }
    | expr expr '-'   { $$ = $1 - $2; }
    | expr expr '*'   { $$ = $1 * $2; }
    | expr expr '/'   { 
                          if ($2 == 0) { 
                              printf("Error: Division by zero!\n"); 
                              valid = 0; 
                              $$ = 0; 
                          } else {
                              $$ = $1 / $2; 
                          }
                       }
    | NUMBER          { $$ = $1; }
    ;
%%

void yyerror(const char *s) {
    printf("Syntax Error: %s\n", s);
    valid = 0;
}

int main() {
    printf("Enter postfix expression:\n");
    if (yyparse() == 0 && valid) {
        printf("Valid Postfix Expression\n");
        printf("Result = %d\n", result);
    } else {
        printf("Invalid Postfix Expression\n");
    }
    return 0;
}





8.Desk calculator with error recovery.


lex code 



%{
#include "y.tab.h"
#include <stdlib.h>
%}

%%
[0-9]+      { yylval = atoi(yytext); return NUMBER; }
[+]         { return PLUS; }
[-]         { return MINUS; }
[*]         { return MULT; }
[/]         { return DIV; }
[(]         { return LPAREN; }
[)]         { return RPAREN; }
[\n]        { return '\n'; }
[ \t]+      ;     // ignore spaces and tabs
.           { return yytext[0]; }   // any unknown character
%%

int yywrap(void) { return 1; }





yacc code 




%{
#include <stdio.h>
#include <stdlib.h>

int yylex(void);
void yyerror(const char *s);
%}

%token NUMBER
%token PLUS MINUS MULT DIV LPAREN RPAREN

%left PLUS MINUS
%left MULT DIV

%%
input:
      /* empty */
    | input line
    ;

line:
      expr '\n'           { printf("= %d\n", $1); }
    | error '\n'          { 
                              yyerror("Invalid expression, please try again."); 
                              yyerrok; 
                          }
    ;

expr:
      expr PLUS expr       { $$ = $1 + $3; }
    | expr MINUS expr      { $$ = $1 - $3; }
    | expr MULT expr       { $$ = $1 * $3; }
    | expr DIV expr        { 
                                if ($3 == 0) {
                                    yyerror("Division by zero!");
                                    $$ = 0;
                                } else {
                                    $$ = $1 / $3;
                                }
                            }
    | LPAREN expr RPAREN   { $$ = $2; }
    | NUMBER               { $$ = $1; }
    ;
%%

void yyerror(const char *s) {
    fprintf(stderr, "Error: %s\n", s);
}

int main() {
    printf("Mini Desk Calculator (with error recovery)\n");
    printf("Enter arithmetic expressions (Ctrl+D to exit):\n");
    yyparse();
    return 0;
}
















9.Parser for ''FOR'' loop statements.



lex code


%{
#include "y.tab.h"
#include <string.h>
#include <stdlib.h>
%}

%%
for                return FOR;
[a-zA-Z_][a-zA-Z0-9_]*   { yylval.str = strdup(yytext); return ID; }
[0-9]+             { yylval.num = atoi(yytext); return NUM; }
"<"                return LT;
"="                return ASSIGN;
"++"               return INC;
";"                return SEMI;
"("                return LPAREN;
")"                return RPAREN;
"{"                return LBRACE;
"}"                return RBRACE;
[ \t\n]+           ;        // skip whitespace
.                  { return yytext[0]; }
%%

int yywrap() { return 1; }








yacc code


%{
#include <stdio.h>
#include <stdlib.h>
void yyerror(const char *s);
int yylex(void);
%}

%union {
    char *str;
    int num;
}

%token <str> ID
%token <num> NUM
%token FOR
%token LT ASSIGN INC
%token SEMI LPAREN RPAREN LBRACE RBRACE

%%
program:
      statement_list
    ;

statement_list:
      statement
    | statement_list statement
    ;

statement:
      for_loop
    | LBRACE statement_list_opt RBRACE
    ;

statement_list_opt:
      /* empty */
    | statement_list
    ;

/* for loop syntax */
for_loop:
    FOR LPAREN for_parts RPAREN statement
    {
        printf("✅ Valid for loop syntax\n");
    }
    ;

/* allow any of init/cond/incr to be optional */
for_parts:
      /* empty */                         /* for(;;) */
    | init_opt SEMI cond_opt SEMI incr_opt /* normal form */
    ;

init_opt:
      /* empty */
    | ID ASSIGN NUM
    ;

cond_opt:
      /* empty */
    | ID LT NUM
    ;

incr_opt:
      /* empty */
    | ID INC
    ;
%%

void yyerror(const char *s) {
    fprintf(stderr, "❌ Syntax error: %s\n", s);
}

int main(void) {
    printf("Enter your for loop:\n");
    return yyparse();
}








10.Intermediate code (IC) generator for arithmetic expression.




lex code 

%{
#include "y.tab.h"
#include <stdlib.h>
#include <string.h>
%}

%%
[ \t\r\n]+          ;                     /* ignore spaces and newlines */
[a-zA-Z]         { yylval.c = yytext[0]; return ID; }
[0-9]+           { yylval.c = yytext[0]; return NUM; }

"="              { return '='; }
"("              { return '('; }
")"              { return ')'; }
"*"              { return '*'; }
"/"              { return '/'; }
"+"              { return '+'; }
"-"              { return '-'; }
%%

int yywrap() { return 1; }









yacc code


%{
#include <stdio.h>
#include <stdlib.h>

int yylex();
void yyerror(const char *s);

int temp = 1;   // Temporary variable counter
%}

%union {
    char c;     // store character for ID and NUM
    int n;      // for temporary variable number
}

%token <c> ID NUM
%type <n> expr

%left '+' '-'
%left '*' '/'

%%
stmt : ID '=' expr
       {
           printf("%c = t%d\n", $1, $3);
       }
     ;

expr : expr '+' expr
       {
           printf("t%d = t%d + t%d\n", temp, $1, $3);
           $$ = temp++;
       }
     | expr '-' expr
       {
           printf("t%d = t%d - t%d\n", temp, $1, $3);
           $$ = temp++;
       }
     | expr '*' expr
       {
           printf("t%d = t%d * t%d\n", temp, $1, $3);
           $$ = temp++;
       }
     | expr '/' expr
       {
           printf("t%d = t%d / t%d\n", temp, $1, $3);
           $$ = temp++;
       }
     | '(' expr ')'
       {
           $$ = $2;
       }
     | ID
       {
           $$ = temp++;
           printf("t%d = %c\n", $$, $1);
       }
     | NUM
       {
           $$ = temp++;
           printf("t%d = %c\n", $$, $1);
       }
     ;
%%

void yyerror(const char *s) {
    printf("Error: %s\n", s);
}

int main() {
    printf("Enter expression like a=b+c*d :\n");
    yyparse();
    return 0;
}
